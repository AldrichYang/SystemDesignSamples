# 示例说明
男孩去追女孩，多次尝试。每次尝试失败之后，恢复初始状态

## 简单实现

设计方案：Boy类定义一个中间变量，保留这个原始状态

设计问题：
1. Client类属于高层模块(或者说非近亲模块的调用者)处理boy backup状态的保存和恢复。而这个状态对于高层模块是多余的。
状态的保存和恢复应该是Boy类的职责，而不应该让高层模块来完成。
这破坏了Boy的封装性，或者说Boy类没有封装好

改进思路：
1. 在boy类中增加方法保存这个状态。
不推荐。因为 **违反了单一职责原则**。
Boy类职责是追求女生，而保留和恢复原始状态则应该由另外一个类来承担，这个类取名为备忘录。

## 备忘录实现1

设计方案：
1. 增加一个新的类Memento,负责状态的保存和备份
2. Boy类中增加创建备忘录和恢复备忘录的功能

设计优点：
1. 程序中不需要重复定义Boy类对象

设计问题：
1.  **违反了迪米特法则**，它告诉我们只和朋友类通信。这个备忘录对象不是Client必须要通信的朋友类。
对高层模块来说，它只希望创建一个备份点，在需要的时候恢复到这个备份点就成，它并不关心到底有没有这个备忘录。

改进思路：
1. 把备忘录再包装一下，建立一个管理类，管理这个备忘录

## 备忘录实现2

设计方案：
1. 创建一个备忘录管理者

设计优点：
1. 需要备份的时候创建一个备份，然后丢给备份管理者进行管理，需要的时候再从管理者手中取回
这个备份者类似一个备份的仓库管理员。
这就是备忘录模式

## 备忘录模式的扩展
### clone方式的备忘录
发起人角色通过clone代替备忘录角色。
备忘录角色不存在了，备忘录管理角色也融合到发起人角色中。

备注:设计模式比java要早，以前没有clone.

### 多状态的备忘录
主要是通过hashMap来管理多状态
为什么要使用hashMap?不用Originator的对象的拷贝。
因为这样做就破坏了发起人角色的通用性，在做恢复动作的时候需要对该对象进行多次赋值操作，也容易出错

### 多备份的备忘录
把备忘录管理器修改一下，容纳备忘录的容器修改为Map类型即可

### 只读的安全备忘录
通过内部类实现备忘录，确保只有发起人可以访问。